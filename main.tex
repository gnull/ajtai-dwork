\documentclass[oneside, a4paper]{article}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{url, hyperref}
\usepackage[shortlabels]{enumitem}
\usepackage{amssymb,amsthm,amsmath,mathtools}
\usepackage{listings}
\usepackage[many]{tcolorbox}
\usepackage{array}
\usepackage{float}

\usepackage{geometry}
 \geometry{
   a4paper,
   left=20mm,
   right=20mm,
 }

\usepackage{filecontents}

\theoremstyle{plain}
\newtheorem{theorem}{Теорема}
\newtheorem{lemma}[theorem]{Лемма}
\newtheorem{exce}{Упражнение}
\theoremstyle{definition}
\newtheorem{defn}{Определение}
\newtheorem{example}{Пример}
\theoremstyle{remark}
\newtheorem{remark}{Замечание}

% \renewcommand{\thesection}{}
% \renewcommand{\thesubsection}{}

\newenvironment{definition}[1]{%
\begin{tcolorbox}[breakable,enhanced]
\begin{defn}[#1]
}{%
\end{defn}
\end{tcolorbox}
}

\newenvironment{greybox}[1]{%
\begin{tcolorbox}[breakable,enhanced, adjusted title = #1]
}{%
\end{tcolorbox}
}

\DeclareMathOperator{\lcm}{LCM}
\DeclareMathOperator{\round}{Round}
\DeclareMathOperator{\Span}{span}
\DeclareMathOperator{\dist}{dist}

\newcommand\p{\ensuremath \mathbf p}
\newcommand\N{\ensuremath \mathcal N}
\newcommand\PP{\ensuremath \mathcal P}
\newcommand\LL{\ensuremath \mathcal L}
\newcommand\KK{\ensuremath \mathcal K}
\newcommand\R{\ensuremath \mathbb R}
\newcommand\Z{\ensuremath \mathbb Z}
\newcommand\HS{\ensuremath \operatorname{\mathcal H Samp}}
\newcommand\HH{\ensuremath \operatorname{\mathcal H}}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\DeclarePairedDelimiter\norm{\lVert}{\rVert}
\DeclarePairedDelimiter\ang{\langle}{\rangle}

\DeclareRobustCommand{\divby}{%
  \mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}

\begin{document}

\title{Конспект статьи \\ \foreignlanguage{english}{<<The First and Fourth Public-Key Cryptosystems
with Worst-Case/Average-Case Equivalence>>  \cite{ajtaidwork}}}
\author{Олейников Иван \\ \url{ivan.oleynikov95@gmail.com}}
\date{\today}
\maketitle

Этот документ содержит конспект того, что я планировал рассказать за одно занятие на семинаре по теоретической
информатике в СПбГУ \footnote{\url{https://groups.google.com/forum/\#!forum/spbsu-teorseminar}}. Секции до
<<\nameref{sec:decr}>> включительно самые простые, их я разобрал на семинаре устно, поэтому они описаны не слишком
подробно. Остальные секции, начиная с <<\nameref{sec:corr_proof}>>, содержат основную часть статьи, именно её мне и не
удалось разобрать их к началу семинара, поэтому после семинара я написал этот конспект.

\tableofcontents

\section{Предварительные определения и обозначения}

\begin{defn}[$\HS^{m, R}_{u_0 \dots u_l}$]
$\HS^{m, R}_{u_0 \dots u_l}$~--- это распределение на векторах из $\R^m$, где $\{u_i\}$~--- это набор любых
ортогональных векторов. Прежде, чем определить его, определим $\HS^{1, R}_{u}$, распределение на $\R$.
\end{defn}

\newpage
\section{Описание криптосистемы}

Криптосистема будет паметризоваться несколькими значениями: параметром надёжности~--- $n$ и длиной шифруемого сообщения
в битах~--- $(l+1)$. Пользователь криптосистемы может выбрать их какими угодно, но от них будут зависеть свойства
криптосистемы, такие как <<надёжность>>~--- вероятность успешного взлома. Мы часто будем работать в $\R^{n+l}$, поэтому
для краткости записи обозначим $m = n + l$. Ещё при задании криптосистемы будем пользоваться функциями $\rho(n)$ и
$R(n)$, точные значения для которых мы выберем в самом конце при доказательстве надёжности.

Наша криптосистема будет шифровать сообщения из $l+1$ бит~--- $b_0, b_1 \dots b_l \in \{0,1\}$. Результатом шифрования
сообщения будет вектор $x \in \R^m$ (как мы увидим дальше, этот вектор всегда будет лежать внутри параллелепипеда
$\PP$, определённого ниже).

Секретный ключ нашей криптосистемы будет состоять из $u_0, u_1 \dots u_l \in \R^m$~--- набора из $l+1$ ортогональных
векторов. Публичный ключ будет состоять из тройки $(\PP, V, D)$ наборов векторов в $\R^m$:
\begin{description}
\item[$\PP = \{p_1 \dots p_m\}$~---] эти вектора задают базис решётки, по модулю которой будет вычисляться шифруемое
сообщение. То есть результат шифрования будет лежать в $\R^m/\LL(\PP)$. (Мы будем нарушать нотацию и обозначать символом
$\PP$ как множество векторов, задающих базис этой решётки, так и фундаментальный параллелепипед этой решётки $\PP =
\left \{\sum_i a_i p_i \mid a_1, a_2 \dots a_m \in [0, 1) \right\}$.)
\item[$V = \{v_0 \dots v_l\}$~---] эти ветора будут использоваться для кодирования сообщения (их не случайно ровно
столько же, сколько бит в сообщении~--- для кодирования сообщения мы будем вычислять сумму подмножества $V$,
задаваемого битами сообщения).
\item[$D = \{d_1 \dots d_{m'}\}$~---] эти ветора используются для наложения «шума» на шируемое сообщение, чтобы
противнику быто «труднее» восстановить сообщение. $m'(n)$~--- это функция от $n$, которую мы выберем позже при
доказательстве коррекности криптосистемы (можно представлять себе, что чем больше $m'$, тем более <<сильный>> шум
накладывается на сообщение).
\end{description}

Как мы увидим в следующей секции, все вектора из множеств $\PP$, $V$ и $D$ публичного члюча будут выбираться из
распределения $\xi_R + \pi_\rho$ (с некоторыми дополнительными требованиями). Это значит, что они все будут «близки» к
пересечению семейств гиперплоскостей $\bigcap_i \HH_{u_i}$.

\subsection{Генерация ключей}
В этой секции мы опишем вероятностный алгоритм генерации ключей $G$, который будет принимать на вход параметр безопасности
$n$ и выдавать пару из публичного и секретного ключей~---
\[
(
\underbrace{\{u_i\}}_{\substack{\text{секретный} \\ \text{ключ}}},
\underbrace{(\PP, V, D)}_{\substack{\text{публичный} \\ \text{ключ}}}
) \gets G(1^n).
\]

\emph{Выбор секретного ключа $\{u_i\}$.} Независимо выберем: (a) $\{e_i\}$~--- вектора единичной длины, задающие
направления для $\{u_i\}$, (b) их длины $\norm{u_i} \in \R$. После этого можно будет положить $u_i = e_i \norm{u_i}$.
\begin{enumerate}[(a)]
\item Будем выбирать случайные значения для $\{e_i\}$ одно за другим~--- значение для $e_i$ будет выбирать после того,
как значения для $e_0, e_1 \dots e_{i-1}$ уже выбраны. Выберем $e_i$ из равномерного распределения на сфере радиуса $1$
в пространстве $\Span \{e_0, e_1 \dots e_{i-1}\}^\bot$, ортогональном порождённому выбранными ранее векторами. ($e_0$
выбирается из оригинального пространства $\R^m$, $e_1$~--- из его $(m-1)$-мерного подпространства и так далее.)

По выбору этих векторов ясно, что они всегда будут ортогональны. Распределение, из которого мы выбираем $e_i$ зависит от
предыдущих векторов $e_0 \dots e_{i-1}$. Но легко заметить, что несмотря на это итоговое распределение всего множества
векторов $\{u_i\}$ не изменится, если выбирать их в другом порядке, --- оно симметрично относительно перестановок
$\{u_i\}$.

\item Длины $\{u_i\}$ выберем независимо друг от друга таким образом: выберем $y$ из $\mathcal B^{(m)}(0,1)$~---
равномерного распределения на шаре радиуса $1$ с центром в начале координат в $n$-мерном пространстве $\R^n$; положим
очередное значение $\norm{u_i} := \norm{y}$. (Эту процедуру проделаем для каждого $i$.)
\end{enumerate}

\emph{Выбор публичного ключа.} Секретный ключ мы уже выбрали. Наш выбор публичного ключа будет зависеть от него.  
Все вектора из $V$, $D$ и $\PP$ выберем независимо друг от друга из распределения $\xi_R + \pi_\rho$. Напомним, что
определение $\xi_R = \HS^{m, R}_{u_0 \dots u_l}$ зависит от секретного ключа $\{u_i\}$.

Но какие попало значения из $\xi_R + \pi_\rho$ в качестве векторов публичного ключа не подойдут нам для шифрования.
Чтобы шифрование и дешифрование работало, нам нужно потребовать от векторов выполнения нескольких дополнительных свойств:
\begin{description}
\item[$V$~---] При разложении $V$ на $AZ + Q + T$ как это было описано в определении $\xi_R + \pi_\rho$, целочисленная
матрица $A$ должна быть обратима по ${\mod 2}$.
\item[$\PP$~---] Ширина параллелепипеда должна быть не менее $\KK(n)/(n+l)^2$, а число рациональных точек в нём~--- $\PP
\cap 2^{-\p}\Z^{n+l}$ должно быть нечётным. (Ещё нам нужно, чтобы $\{p_i\}$ были линейно независимы, но это свойство
нарушается вероятностью, экспоненциально убывающей с увеличением $n$, поэтому даже не будем останавливаться на нём.)
\begin{defn}[Ширина параллелепипеда]
Шириной параллелепипеда $\PP$ будем называть максимальное по его вершинам расстояние от вершины параллелепипеда до
пространства порождённого остальными вершинами:
\[
w(\PP) = \max_i \dist(p_i, \Span \{ p_j \mid j \neq i\}).
\]
\end{defn}

Требование на число точек гарантирует нам, что все подгруппы $2^{-\p}\Z / \PP$ имеют нечётный порядок. Поэтому функция
$(v \mapsto 2v)$ будет биекцией на этом множестве. Смысл требования к ширине параллелепипеда мы объясним в секции
<<\nameref{sec:corr_proof}>>.
\end{description}

Позже, в секции <<\nameref{sec:corr_proof}>> мы докажем, что эти требования выполняются с константной вероятностью для
случайных векторов из $\xi_R + \pi_\rho$. Если не повезло и какое-то требование не выполнилось, то мы можем генерировать
вектора заново раз за разом, пока не получится. При повторении генерации несколько раз, вероятность того, что каждый
из этих раз будет неудачным, убывает экспоненциально с числом повторений. А число повторений в среднем будет
константным.

\subsection{Шифрование} Шифрующий алгоритм принимает на вход сообщение $b_0 b_1 \dots
b_l$ из $l+1$ бит. Выберем равномерно и независимо $m'$ бит $\delta_1 \dots
\delta_{m'}$, и вернём в качестве результата шифрования значение
\[
x = \sum_{i = 0}^l b_i v_i + \sum_{i = 1}^m 2 \delta_i d_i \mod \PP.
\]

Первое слагаемое в этой сумме~--- это код сообщения, по нему можно восстановить
сообщение, даже не имея секретного ключа, что демонстрируется упражнением ниже.
А второе слагаемое~--- это <<шум>>, который накладывается, чтобы не имеющий
секретного ключа не мог восстановить данные, а имеющий секретный ключ мог это
сделать, избавившись от шума. То есть, секретный ключ позволит нам каким-то
образом выделить $\sum b_i v_i \mod \PP$ из суммы выше.
% В абзаце выше какой-то буллщит, кто этого не понимал раньше, тот этот текст не
% поймёт.

\begin{exce}
По значению
\[
\sum_{i=0}^l b_i v_i \mod \PP
\]
можно восстановить $b_0 \dots b_l$.
% TODO: Уточнить, при каких ограничениях на v_i и \PP
\end{exce}

\subsection{Дешифрование}
\label{sec:decr}
Дешифрующий алгоритм, которому известен секретный ключ
$\{u_0 \dots u_l\}$ и открытый ключ $(\PP, V, D)$, получает на вход $x$,
выданный шифрующим алгоритмом из абзаца выше, и восстанавшивает оригинальное
сообщение $b_0 \dots b_l$.

Напомним, что вектора из $V$ и $D$ получены из распределения $\xi_R + \pi_\rho$
(с некоторыми дополнительными требованиями). А случайную величину из такого
распределения 

Для этого сначала выразим все вектора (включая $x, V, D, \PP$), с которыми мы
работаем, в базисе $\{ z_0 \dots z_l \} \cup \{t_1 \dots t_{n-1}\}$, где
$\{t_i\}$~--- это какой-нибудь ортонормированный базис пространства $\Span
\{z_i\}^\bot$. Затем обнулим соотвествующие $\{t_1 \dots t_{n-1}\}$ компоненты
$x$ (другими словами, спроецируем $x$ на $\Span \{z_i\}$).

\subsection{Доказательство корректности}
\label{sec:corr_proof}
Докажем, что зашифрованные такой криптосистемой данные будут корректно
восстановлены с пренебрежимо малой вероятностью ошибки.

\section{Доказательство надёжности}
Сведём решение \foreignlanguage{english}{worst-case} задачи
\foreignlanguage{english}{Unique Shortest Vector} к взлому определённой нами
криптосистемы.

\bibliographystyle{plain}
\foreignlanguage{english}{
  \bibliography{main}
}
\begin{filecontents}{main.bib}
@article{ajtaidwork,
  author    = {Mikl{\'{o}}s Ajtai and
               Cynthia Dwork},
  title     = {The First and Fourth Public-Key Cryptosystems with Worst-Case/Average-Case
               Equivalence.},
  journal   = {Electronic Colloquium on Computational Complexity {(ECCC)}},
  volume    = {14},
  number    = {097},
  year      = {2007},
  url       = {http://eccc.hpi-web.de/eccc-reports/2007/TR07-097/index.html},
  timestamp = {Tue, 14 Aug 2018 17:08:03 +0200},
  biburl    = {https://dblp.org/rec/bib/journals/eccc/AjtaiD07},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
\end{filecontents}

\end{document}
