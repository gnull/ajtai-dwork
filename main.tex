\documentclass[oneside, a4paper]{article}

\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{url, hyperref}
\usepackage[shortlabels]{enumitem}
\usepackage{amssymb,amsthm,amsmath,mathtools}
\usepackage{listings}
\usepackage[many]{tcolorbox}
\usepackage{array}
\usepackage{float}

\usepackage{geometry}
 \geometry{
   a4paper,
   left=20mm,
   right=20mm,
 }

\usepackage{filecontents}

\theoremstyle{plain}
\newtheorem{theorem}{Теорема}
\newtheorem{lemma}[theorem]{Лемма}
\newtheorem{exce}{Упражнение}
\theoremstyle{definition}
\newtheorem{defn}{Определение}
\newtheorem{example}{Пример}
\theoremstyle{remark}
\newtheorem{remark}{Замечание}

% \renewcommand{\thesection}{}
% \renewcommand{\thesubsection}{}

\newenvironment{definition}[1]{%
\begin{tcolorbox}[breakable,enhanced]
\begin{defn}[#1]
}{%
\end{defn}
\end{tcolorbox}
}

\newenvironment{greybox}[1]{%
\begin{tcolorbox}[breakable,enhanced, adjusted title = #1]
}{%
\end{tcolorbox}
}

\DeclareMathOperator{\lcm}{LCM}
\DeclareMathOperator{\round}{Round}
\DeclareMathOperator{\Span}{span}

\newcommand\p{\ensuremath \mathbf p}
\newcommand\N{\ensuremath \mathcal N}
\newcommand\PP{\ensuremath \mathcal P}
\newcommand\LL{\ensuremath \mathcal L}
\newcommand\KK{\ensuremath \mathcal K}
\newcommand\R{\ensuremath \mathbb R}
\newcommand\Z{\ensuremath \mathbb Z}
\newcommand\HS{\ensuremath \operatorname{\mathcal H Samp}}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\DeclarePairedDelimiter\norm{\lVert}{\rVert}
\DeclarePairedDelimiter\ang{\langle}{\rangle}

\DeclareRobustCommand{\divby}{%
  \mathrel{\vbox{\baselineskip.65ex\lineskiplimit0pt\hbox{.}\hbox{.}\hbox{.}}}%
}

\begin{document}

\title{Конспект статьи \\ \foreignlanguage{english}{<<The First and Fourth Public-Key Cryptosystems
with Worst-Case/Average-Case Equivalence>>  \cite{ajtaidwork}}}
\author{Олейников Иван \\ \url{ivan.oleynikov95@gmail.com}}
\date{\today}
\maketitle

Этот документ содержит конспект того, что я планировал рассказать за одно
занятие на семинаре по теоретической информатике в СПбГУ
\footnote{\url{https://groups.google.com/forum/\#!forum/spbsu-teorseminar}}.
Секции <<\dots>> я разобрал на семинаре устно, поэтому они описаны очень
кратко, с расчётом на посетившего семинар читателя, к тому же они составляют
самую простую часть статьи и их нетрудно изучить самостоятельно. Остальные
секции <<\dots>> содержат основную часть статьи,
именно её мне и не удалось разобрать их к началу семинара, поэтому после семинара
я написал этот конспект.

\tableofcontents

\section{Предварительные определения и обозначения}

\begin{defn}[$\HS^{m, R}_{u_0 \dots u_l}$]
$\HS^{m, R}_{u_0 \dots u_l}$~--- это распределение на векторах из $\R^m$, где $\{u_i\}$~--- это набор любых
ортогональных векторов. Прежде, чем определить его, определим $\HS^{1, R}_{u}$, распределение на $\R$.
\end{defn}

\newpage
\section{Описание криптосистемы}

Криптосистема будет паметризоваться несколькими значениями: параметром надёжности~--- $n$ и длиной шифруемого сообщения
в битах~--- $(l+1)$. Мы часто будем работать в $\R^{n+l}$, поэтому для краткости записи обозначим $m = n + l$. Ещё при
задании криптосистемы будем пользоваться функциями $\rho(n)$ и $R(n)$, точные значения для которых мы выберем в самом
конце при доказательстве надёжности.

Секретный ключ нашей криптосистемы будет состоять из $u_0, u_1 \dots u_l \in \R^m$~--- набора из $l+1$ ортогональных
векторов. Публичный ключ будет состоять из тройки $(\PP, V, D)$ наборов векторов в $\R^m$:
\begin{description}
\item[$\PP &= \{p_1 \dots p_m\}$~---] эти вектора задают базис решётки, по модулю которой будет вычисляться шифруемое
сообщение. То есть результат шифрования будет лежать в $\R^m/\LL(\PP)$.
\item[$V &= \{v_0 \dots v_l\}$~---] эти ветора будут использоваться для кодирования сообщения (их не случайно ровно
столько же, сколько бит в сообщении~--- для кодирования сообщения мы будем вычислять сумму подмножества $V$,
задаваемого битами сообщения).
\item[$D &= \{d_1 \dots d_{m'}\}$~---] эти ветора используются для наложения «шума» на шируемое сообщение, чтобы
противнику быто «труднее» восстановить сообщение. $m'(n)$~--- это функция от $n$, которую мы выберем позже при
доказательстве коррекности криптосистемы (можно представлять себе, что чем больше $m'$, тем более <<сильный>> шум
накладывается на сообщение).
\end{description}

\begin{table}[H]
\centering
\begin{tabular}{c | c | m{7cm}}
\emph{Сущность} & \emph{Обозначение} & \emph{Формат} \\
\hline
\hline
Секретный ключ & $\{u_0 \dots u_l\}$ & Набор взаимно ортогональных векторов в $\R^m$ \\
\hline
Публичный ключ
&
\parbox{3cm}{
\[
\begin{aligned}
\PP &= \{p_1 \dots p_m\} \\
V &= \{v_0 \dots v_l\} \\
D &= \{d_1 \dots d_{m'}\}
\end{aligned}
\]
}
& Три набора векторов в $\R^m$, каждый из которых <<близок>> к решётке $L^\bot
\{u_i\}$ \\
\hline
Шифруемое сообщение & $b_0 \dots b_l$ & Строка из $l+1$ бит \\
\hline
Код сообщения & $x$ & Внутренняя точка параллелепипеда $\PP^-$ \\
\end{tabular}
\end{table}

\subsection{Генерация ключей}
Вероятностному алгоритму генерации подаётся на вход параметр безопасности $n$, а
он должен выдать пару из секретного $u_0 \dots u_l$ и публичного $(\PP, V, D)$
ключей.

\emph{Секретный ключ.} Выберем независимо $e_0 \dots e_l$~--- направления
векторов $u_0 \dots u_l$ и их длины~--- $\norm{u_0} \dots \norm{u_l}$.
Направления для векторов будем выбирать поочерёдно~--- $e_i$ будем выбирать уже
при выбранных $e_0 \dots e_{i-1}$ таким образом: $e_i$ выберем из равномерного
распределения на сфере радиуса $1$ с центром в начале координат
$(m-i)$-мерного пространства $\Span \{e_0 \dots e_{i-1}\}^\bot$. А длину
каждого из $u_i$ выберем независимо как длину случайного вектора из равномерного
распределения в $m$-мерном шаре с радиусом $1$~--- $\mathcal B^{(m)}(0,1)$:
\[
\norm{u_i} =
\left [
\begin{aligned}
&a \gets \mathcal B^{(m)}(0,1) \\
&\text{return } \norm{a}
\end{aligned}
\right ].
\]
Мы задали вероятностный алгоритм генерации секретного ключа~--- $u_i = \norm{u_i}
e_i$.

\emph{Публичный ключ.} Выберем независимо все вектора из $V$, $D$ и $\PP$ из
$\xi_R + \pi_\rho$, но дополнительно потребуем выполнения нескольких требований.
\begin{description}
\item[$V$]~--- При разложении $V$ на $AZ + Q + T$, целочисленная матрица $A$
должна быть обратима по $\mod 2$.
\item[$D$]~--- \emph{(Никаких требований.)}
\item[$\PP$]~--- Ширина параллелепипеда должна быть не менее $\KK(n)/(n+l)^2$, а
число рациональных точек в нём~--- $\PP \cap 2^{-\p}\Z^{n+l}$ должно быть нечётным.
\begin{definition}{Ширина параллелепипеда}
TODO
\end{definition}
\end{description}
Если какие-то из этих условий не выполняются, заново перегенерируем значения
векторов из множества, для которого не выполнилось условие. Позже, будет
доказано, что для случайных наборов векторов эти условия выполняются с
константной вероятностью.

\subsection{Шифрование} Шифрующий алгоритм принимает на вход сообщение $b_0 b_1 \dots
b_l$ из $l+1$ бит. Выберем равномерно и независимо $m'$ бит $\delta_1 \dots
\delta_{m'}$, и вернём в качестве результата шифрования значение
\[
x = \sum_{i = 0}^l b_i v_i + \sum_{i = 1}^m 2 \delta_i d_i \mod \PP.
\]

Первое слагаемое в этой сумме~--- это код сообщения, по нему можно восстановить
сообщение, даже не имея секретного ключа, что демонстрируется упражнением ниже.
А второе слагаемое~--- это <<шум>>, который накладывается, чтобы не имеющий
секретного ключа не мог восстановить данные, а имеющий секретный ключ мог это
сделать, избавившись от шума. То есть, секретный ключ позволит нам каким-то
образом выделить $\sum b_i v_i \mod \PP$ из суммы выше.
% В абзаце выше какой-то буллщит, кто этого не понимал раньше, тот этот текст не
% поймёт.

\begin{exce}
По значению
\[
\sum_{i=0}^l b_i v_i \mod \PP
\]
можно восстановить $b_0 \dots b_l$.
% TODO: Уточнить, при каких ограничениях на v_i и \PP
\end{exce}

\subsection{Дешифрование} Дешифрующий алгоритм, которому известен секретный ключ
$\{u_0 \dots u_l\}$ и открытый ключ $(\PP, V, D)$, получает на вход $x$,
выданный шифрующим алгоритмом из абзаца выше, и восстанавшивает оригинальное
сообщение $b_0 \dots b_l$.

Напомним, что вектора из $V$ и $D$ получены из распределения $\xi_R + \pi_\rho$
(с некоторыми дополнительными требованиями). А случайную величину из такого
распределения 

Для этого сначала выразим все вектора (включая $x, V, D, \PP$), с которыми мы
работаем, в базисе $\{ z_0 \dots z_l \} \cup \{t_1 \dots t_{n-1}\}$, где
$\{t_i\}$~--- это какой-нибудь ортонормированный базис пространства $\Span
\{z_i\}^\bot$. Затем обнулим соотвествующие $\{t_1 \dots t_{n-1}\}$ компоненты
$x$ (другими словами, спроецируем $x$ на $\Span \{z_i\}$).

\subsection{Доказательство корректности}
Докажем, что зашифрованные такой криптосистемой данные будут корректно
восстановлены с пренебрежимо малой вероятностью ошибки.

\section{Доказательство надёжности}
Сведём решение \foreignlanguage{english}{worst-case} задачи
\foreignlanguage{english}{Unique Shortest Vector} к взлому определённой нами
криптосистемы.

\bibliographystyle{plain}
\foreignlanguage{english}{
  \bibliography{main}
}
\begin{filecontents}{main.bib}
@article{ajtaidwork,
  author    = {Mikl{\'{o}}s Ajtai and
               Cynthia Dwork},
  title     = {The First and Fourth Public-Key Cryptosystems with Worst-Case/Average-Case
               Equivalence.},
  journal   = {Electronic Colloquium on Computational Complexity {(ECCC)}},
  volume    = {14},
  number    = {097},
  year      = {2007},
  url       = {http://eccc.hpi-web.de/eccc-reports/2007/TR07-097/index.html},
  timestamp = {Tue, 14 Aug 2018 17:08:03 +0200},
  biburl    = {https://dblp.org/rec/bib/journals/eccc/AjtaiD07},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
\end{filecontents}

\end{document}
